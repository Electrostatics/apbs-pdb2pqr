""" Python APBS No Input Driver File
    
    This module allows a user to run APBS through Python. Use this module if
    you wish to include APBS in a Python-based application.  This specific
    version allows a user to read in data from the Python level without
    using the command line - thus enabling the ability to link seamlessly
    with other Python programs.  Here the 'INPUT and 'PQR' variables are
    predetermined global strings, but can be dynamically created as desired.

    The module mimics the main.c driver that is used in the C version of APBS.
    The functions which are called are located in apbslib.py, which is 
    automatically generated by SWIG to wrap each APBS function.  See the APBS
    documentation for more information about each function.

    To access energy or force vectors for further use, see the appropriate print
    section at the bottom of this script.  NOTE:  You ***MUST*** use

        calcforce comps

    in the input file for each calculation that you wish to obtain a force vector -
    otherwise the vector will NOT be calculated.

    Todd Dolinsky (todd@ccb.wustl.edu)
    Nathan Baker (baker@biochem.wustl.edu)
    Washington University in St. Louis
"""    

__author__ = "Todd Dolinsky, Nathan Baker"
__date__ = "25 January 2005"

INPUT = """read 
    mol pqr ion.pqr                   
end
elec
    mg-manual                        
    dime 65 65 65                                                        
    nlev 4                                                                
    grid 0.33 0.33 0.33              
    gcent mol 1                                                    
    chgm spl2                     
    mol 1                      
    lpbe                          
    bcfl mdh                           
    ion 1 0.000 2.0                 
    ion -1 0.000 2.0               
    pdie 1.0                         
    sdie 78.54                     
    chgm spl2                         
    srfm spl2                          
    srad 1.4                        
    swin 0.3                         
    temp 298.15                     
    gamma 0.105                     
    calcenergy total                   
    calcforce comps                     
end
elec
    mg-manual                       
    dime 65 65 65                     
    nlev 4                            
    grid 0.33 0.33 0.33               
    gcent mol 1                       
    mol 1                             
    lpbe                            
    bcfl mdh                         
    ion 1 0.000 2.0                 
    ion -1 0.000 2.0                  
    pdie 1.0                         
    sdie 1.0                          
    chgm spl2                           
    srfm spl2                          
    srad 1.4                          
    swin 0.3                        
    temp 298.15                    
    gamma 0.105                     
    calcenergy total                     
    calcforce comps                      
end

print energy 1 - 2 end

quit
"""

PQR = "ATOM      1  I   ION     1       0.000   0.000  0.000  1.00  3.00"

Python_kb = 1.3806581e-23
Python_Na = 6.0221367e+23
NOSH_MAXMOL = 20
NOSH_MAXCALC = 20


from apbslib import *
import sys, time
import string
from sys import stdout, stderr

class APBSError(Exception):
    """ APBSError class

        The APBSError class inherits off the Exception module and returns
        a string defining the nature of the error. 
    """
    
    def __init__(self, value):
        """
            Initialize with error message

            Parameters
                value:  Error Message (string)
        """
        self.value = value
        
    def __str__(self):
        """
            Return the error message
        """
        return `self.value`

def getUnitConversion():
    """
        Get the unit conversion from kT to kJ/mol

        Returns
            factor: The conversion factor (float)
    """
    temp = 298.15
    factor = Python_kb/1000.0 * temp * Python_Na
    return factor

def getHeader():
    """ Get header information about APBS
        Returns (header)
            header: Information about APBS
    """

    header = "\n\n\
    ----------------------------------------------------------------------\n\
    Adaptive Poisson-Boltzmann Solver (APBS)\n\
    Version 0.3.2\n\
    \n\
    Nathan A. Baker (baker@biochem.wustl.edu)\n\
    Dept. of Biochemistry and Molecular Biophysics\n\
    Center for Computational Biology\n\
    Washington University in St. Louis\n\
    Additional contributing authors listed in the code documentation.\n\n\
    Copyright (c) 2002-2004. Washington University in St. Louis\n\
    All Rights Reserved.\n\n\
    Portions copyright (c) 1999-2002.  University of California.\n\
    Portions copyright (c) 1995.  Michael Holst.\n\n\
    This program is free software; you can redistribute it and/or modify\n\
    it under the terms of the GNU General Public License as published by\n\
    the Free Software Foundation; either version 2 of the License, or\n\
    (at your option) any later version.\n\
    \n\
    This program is distributed in the hope that it will be useful,\n\
    but WITHOUT ANY WARRANTY; without even the implied warranty of\n\
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\
    GNU General Public License for more details.\n\
    \n\
    You should have received a copy of the GNU General Public License\n\
    along with this program; if not, write to the Free Software\n\
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA\n\
    ----------------------------------------------------------------------\n\
    \n\n"

    return header

def getUsage():
    """ Get usage information about running APBS via Python
        Returns (usage)
            usage: Text about running APBS via Python
    """
    
    usage = "\n\n\
    ----------------------------------------------------------------------\n\
    This driver program calculates electrostatic potentials, energies,\n\
    and forces using both multigrid and finite element methods.\n\
    It is invoked as:\n\n\
      python noinput.py\n\
    ----------------------------------------------------------------------\n\n"

    return usage

def main():
    """ Main driver for testing.  Runs APBS on given input file """
    
    # Initialize the MALOC library
    startVio()

    # Initialize variables, arrays
    com = Vcom_ctor(1)
    rank = Vcom_rank(com)
    size = Vcom_size(com)
    mgparm = MGparm()
    pbeparm = PBEparm()
    mem = Vmem_ctor("Main")
    pbe = new_pbelist(NOSH_MAXMOL)
    pmg = new_pmglist(NOSH_MAXMOL)
    pmgp = new_pmgplist(NOSH_MAXMOL)
    realCenter = double_array(3)
    totEnergy = double_array(NOSH_MAXCALC)
    qfEnergy = double_array(NOSH_MAXCALC)
    qmEnergy = double_array(NOSH_MAXCALC)
    dielEnergy = double_array(NOSH_MAXCALC)
    npEnergy = double_array(NOSH_MAXCALC)
    nenergy = int_array(NOSH_MAXCALC)
    nforce = int_array(NOSH_MAXCALC)
    atomforce = new_atomforcelist(NOSH_MAXCALC)
    
    # Start the main timer
    main_timer_start = time.clock()

    # Check invocation
    stdout.write(getHeader())
    if len(sys.argv) != 1:
        stderr.write("main:  Called with %d arguments!\n" % len(sys.argv))
        stderr.write(getUsage())
        raise APBSError, "Incorrect Usage!"

    # Parse the input file
    nosh = NOsh()
    NOsh_ctor2(nosh, rank, size)

    # Instead of having an input file, we have a string!

    sock = Vio_setup("r", "BUFF","ASC", "localhost", "0", INPUT);
    if not NOsh_parse(nosh, sock):
        stderr.write("main:  Error while parsing input file.\n")
        raise APBSError, "Error occurred!"
    
    # Load the molecules using Valist_load routine, thereby
    # loading atoms directly into the valist object, removing
    # the need for an actual PQR file

    alist = new_valist(NOSH_MAXMOL)

    atoms = string.split(PQR,"\n")
    x = double_array(len(atoms))
    y = double_array(len(atoms))
    z = double_array(len(atoms))
    chg = double_array(len(atoms))
    rad = double_array(len(atoms))

    for i in range(len(atoms)):
        atom = atoms[i]
        params = string.split(atom)
        set_entry(x,i,float(params[5]))
        set_entry(y,i,float(params[6]))
        set_entry(z,i,float(params[7]))
        set_entry(chg,i,float(params[8]))
        set_entry(rad,i,float(params[9]))

    # If there are more than one PQR file, make multiple Valist
    # objects

    myAlist = make_Valist(alist,0)
    Valist_load(myAlist, len(atoms), x,y,z,chg,rad)  

    # Initialize the energy holders

    potList = []
    potentials = double_array(len(atoms))

    # Initialize the force holders

    qfforceList = []
    ibforceList = []
    dbforceList = []
    npforceList = []

    # Load the dieletric maps

    dielXMap = new_gridlist(NOSH_MAXMOL)
    dielYMap = new_gridlist(NOSH_MAXMOL)
    dielZMap = new_gridlist(NOSH_MAXMOL)
    if loadDielMaps(nosh, dielXMap, dielYMap, dielZMap) != 1:
        stderr.write("Error reading dielectric maps!\n")
        raise APBSError, "Error reading dielectric maps!"
    
    # Load the kappa maps
    kappaMap = new_gridlist(NOSH_MAXMOL)
    if loadKappaMaps(nosh, kappaMap) != 1:
        stderr.write("Error reading kappa maps!\n")
        raise APBSError, "Error reading kappa maps!"

    # Load the charge maps
    chargeMap = new_gridlist(NOSH_MAXMOL)
    if loadChargeMaps(nosh, chargeMap) != 1:
        stderr.write("Error reading charge maps!\n")
        raise APBSError, "Error reading charge maps!"

    # Do the calculations

    stdout.write("Preparing to run %d PBE calculations. \n" % nosh.ncalc)

    for icalc in xrange(nosh.ncalc):
        stdout.write("---------------------------------------------\n")
        calc = NOsh_getCalc(nosh, icalc)
        mgparm = calc.mgparm
        pbeparm = calc.pbeparm
        if calc.calctype != 0:
            stderr.write("main:  Only multigrid calculations supported!\n")
            raise APBSError, "Only multigrid calculations supported!"

        for k in range(0, nosh.nelec):
            if NOsh_elec2calc(nosh,k) >= icalc:
                break

        name = NOsh_elecname(nosh, k+1)
        if name == "":
            stdout.write("CALCULATION #%d:  MULTIGRID\n" % (icalc+1))
        else:
            stdout.write("CALCULATION #%d (%s): MULTIGRID\n" % ((icalc+1),name))
        stdout.write("Setting up problem...\n")
	
        # Routine initMG
	
        if initMG(icalc, nosh, mgparm, pbeparm, realCenter, pbe, 
              alist, dielXMap, dielYMap, dielZMap, kappaMap, chargeMap, 
              pmgp, pmg) != 1:
            stderr.write("Error setting up MG calculation!\n")
            raise APBSError, "Error setting up MG calculation!"
	
        # Print problem parameters 
	
        printMGPARM(mgparm, realCenter)
        printPBEPARM(pbeparm)
        Python_kbT = Python_kb*Python_Na*(pbeparm.temp)/1000.0
	
        # Solve the problem : Routine solveMG
	
        thispmg = get_Vpmg(pmg,icalc)

        if solveMG(nosh, thispmg, mgparm.type) != 1:
            stderr.write("Error solving PDE! \n")
            raise APBSError, "Error Solving PDE!"

        # Set partition information : Routine setPartMG

        if setPartMG(nosh, mgparm, thispmg) != 1:
            stderr.write("Error setting partition info!\n")
            raise APBSError, "Error setting partition info!"
	
        # Write out energies : Routine energyMG, npenergyMG
        # Create pointers to variables that store energies,
        # place in appropriate array, and delete pointers
        # See SWIG documentation for pointer function info
	
        totEng = ptrcreate("double",0.0)
        qfEng = ptrcreate("double",0.0)
        qmEng = ptrcreate("double",0.0)
        dielEng = ptrcreate("double",0.0)
        npEng = ptrcreate("double",0.0)
        neng = ptrcreate("int",0.0)

        energyMG(nosh, icalc, thispmg, nenergy,  totEng, qfEng, qmEng, dielEng)
        #npenergyMG(nosh, icalc, thispmg, nenergy, npEng)
	
        ptrset(totEnergy,ptrvalue(totEng),icalc)
        ptrset(qfEnergy,ptrvalue(qfEng),icalc)
        ptrset(qmEnergy,ptrvalue(qmEng),icalc)
        ptrset(dielEnergy,ptrvalue(dielEng),icalc)
        ptrset(npEnergy,ptrvalue(npEng),icalc)
        ptrset(nenergy,ptrvalue(neng),icalc)
        ptrfree(totEng)
        ptrfree(qfEng)
        ptrfree(qmEng)
        ptrfree(dielEng)
        ptrfree(npEng)
        ptrfree(neng)
	
        # Set partition information

        nfor = ptrcreate("int",0.0)
        forceMG(mem, nosh, pbeparm, mgparm, thispmg, nfor, atomforce, alist)
        ptrset(nforce,ptrvalue(nfor), icalc)
        ptrfree(nfor)
	
        # Write out data from MG calculations : Routine writedataMG	
        writedataMG(rank, nosh, pbeparm, thispmg)
	
        # Write out matrix from MG calculations	
        writematMG(rank, nosh, pbeparm, thispmg)

        # Get the potentials from the calculations
               
        potentials = getPotentials(nosh, pbeparm, thispmg, myAlist)
        potList.append(potentials)

        # Get the forces

        qfforceList.append(getqfForces(atomforce, myAlist))
        ibforceList.append(getibForces(atomforce, myAlist))
        dbforceList.append(getdbForces(atomforce, myAlist))
        npforceList.append(getnpForces(atomforce, myAlist))

    # Handle print statements

    if nosh.nprint > 0:
        stdout.write("---------------------------------------------\n")
        stdout.write("PRINT STATEMENTS\n")
    for iprint in xrange(nosh.nprint):
        if NOsh_printWhat(nosh, iprint) == NPT_ENERGY:
            printEnergy(com, nosh, totEnergy, iprint)
        elif NOsh_printWhat(nosh, iprint) == NPT_FORCE:
            printForce(com, nosh, nforce, atomforce, iprint)
        else:
            stdout.write("Undefined PRINT keyword!\n")
            break

    # Put the potentials into Python readable arrays

    mypotlist = []
    for i in range(len(potList)):
        mypotlist.append([])
        for j in range(len(atoms)):
            mypotlist[i].append(get_entry(potList[i], j))

    # Print the per-atom energies
    #    Each list corresponds to a calculation, having len(atoms) entries

    factor = getUnitConversion()
    for i in range(len(mypotlist)):
        list = mypotlist[i]
        print "\nPer-atom energies from calculation %i" % (i+1)
        for j in range(len(list)):
            atom = list[j]
            print "\t%i\t%.4f" % ((j+1), (float(atom) * factor *0.5))

    # Put the forces in Python readable arrays
    
    myqflist = []
    for i in range(len(qfforceList)):
        myqflist.append([])
        for j in range(len(atoms)):
            coords = get_double_entry(qfforceList[i],j)
            pycoords = []
            for k in range(3):
                val = get_entry(coords,k)
                if val < 1e-20: val = 0
                pycoords.append(float(val) * factor)
            myqflist[i].append(pycoords)

    myiblist = []
    for i in range(len(ibforceList)):
        myiblist.append([])
        for j in range(len(atoms)):
            coords = get_double_entry(ibforceList[i],j)
            pycoords = []
            for k in range(3):
                val = get_entry(coords,k)
                if val < 1e-20: val = 0
                pycoords.append(float(val) * factor)
            myiblist[i].append(pycoords)

    mydblist = []
    for i in range(len(dbforceList)):
        mydblist.append([])
        for j in range(len(atoms)):
            coords = get_double_entry(dbforceList[i],j)
            pycoords = []
            for k in range(3):
                val = get_entry(coords,k)
                if val < 1e-20: val = 0
                pycoords.append(float(val) * factor)
            mydblist[i].append(pycoords)


    mynplist = []
    for i in range(len(npforceList)):
        mynplist.append([])
        for j in range(len(atoms)):
            coords = get_double_entry(npforceList[i],j)
            pycoords = []
            for k in range(3):
                val = get_entry(coords,k)
                if val < 1e-20: val = 0
                pycoords.append(float(val) * factor)
            mynplist[i].append(pycoords)


    # Print the per-atom forces

    for i in range(len(myqflist)):
        qflist = myqflist[i]
        iblist = myiblist[i]
        dblist = mydblist[i]
        nplist = mynplist[i]
        
        print "\nPer-atom forces from calculation %i" % (i+1)
        for j in range(len(qflist)):
            qf = "%.3E %.3E %.3E" % (qflist[j][0], qflist[j][1], qflist[j][2])
            ib = "%.3E %.3E %.3E" % (iblist[j][0], iblist[j][1], iblist[j][2])
            db = "%.3E %.3E %.3E" % (dblist[j][0], dblist[j][1], dblist[j][2])
            np = "%.3E %.3E %.3E" % (nplist[j][0], nplist[j][1], nplist[j][2])
            print "\t%i\t%s (qf)" % ((j+1), qf)
            print "\t%i\t%s (ib)" % ((j+1), ib)
            print "\t%i\t%s (db)" % ((j+1), db)
            print "\t%i\t%s (np)" % ((j+1), np)
    
    stdout.write("----------------------------------------\n")
    stdout.write("CLEANING UP AND SHUTTING DOWN...\n")

    # Clean up APBS structures
    #killForce(mem, nosh, nforce, atomforce)
    del nforce
    del atomforce
    killEnergy()
    killMG(nosh, pbe, pmgp, pmg)
    killChargeMaps(nosh, chargeMap)
    killKappaMaps(nosh, kappaMap)
    killDielMaps(nosh, dielXMap, dielYMap, dielZMap)
    killMolecules(nosh, alist)
    del nosh
    
    # Clean up MALOC structures
    del com
    del mem
    stdout.write("\n")
    stdout.write("Thanks for using APBS!\n\n")

    # Stop the main timer
    main_timer_stop = time.clock()
    stdout.write("Total execution time:  %1.6e sec\n" % (main_timer_stop - main_timer_start))

    

if __name__ == "__main__": main()
    
