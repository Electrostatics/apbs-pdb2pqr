# DX formatted potential grid reader for VMD
# - Dave Sept - Washington University
#
proc read_dx {fileName molNum} {
#
# This procedure reads in a dx grid and associates it with
# the molecule <molNum>
#
    puts "Reading in dx data..."
    set valList ""
    set count 0
    set in [open $fileName r]
    set InputLine [gets $in]
    puts $InputLine
    set InputLine [gets $in]
    set InputLine [gets $in]
    set InputLine [gets $in]
    set InputLine [gets $in]
    scan $InputLine "object 1 class gridpositions counts %i %i %i" zgrid ygrid xgrid
    puts "Grid Points per Dimension = x:$xgrid y:$ygrid z:$zgrid"
    set InputLine [gets $in]
    scan $InputLine "origin %e %e %e" xOrigin yOrigin zOrigin
    set origin [list $xOrigin $yOrigin $zOrigin ]
    set InputLine [gets $in]
    scan $InputLine "delta %e %e %e" zdel dum2 dum1
    set InputLine [gets $in]
    scan $InputLine "delta %e %e %e" dum1 ydel dum2
    set InputLine [gets $in]
    scan $InputLine "delta %e %e %e" dum2 dum1 xdel
    set xVec [list [expr $xdel * $xgrid] 0 0 ]
    set yVec [list 0 [expr $ydel * $ygrid] 0 ]
    set zVec [list 0 0 [expr $zdel * $zgrid] ]
    puts "Grid Spacing = x:$xdel y:$ydel z:$zdel"
    # two more object lines - not needed
    set InputLine [gets $in]
    set InputLine [gets $in]
    set total [expr int($xgrid* $ygrid * $zgrid / 3)]
    while {$count < $total} {
        set InputLine [gets $in]
	  scan $InputLine "%e %e %e" v1 v2 v3
        lappend valList $v1 $v2 $v3
        incr count
    }
    if {[expr $xgrid * $ygrid * $zgrid - 3 * $total] == 2} {
	  scan $InputLine "%e %e" v1 v2
        lappend valList $v1 $v2
    }

    if {[expr $xgrid * $ygrid * $zgrid - 3 * $total] == 1} {
	  scan $InputLine "%e"  v1
        lappend valList $v1
    }
    close $in      
      
    puts "Length of list is [llength $valList]"
    puts "Now to show surface in vmd..."
    puts "Origin at: $xOrigin $yOrigin $zOrigin" 
    mol volume $molNum "APBS Potential"  $origin $xVec $yVec $zVec $xgrid $ygrid $zgrid $valList

}


proc add_contour {molNum value color} {
#
# This procedure adds an isocontour to molecule <molNum>
# with the value <value> and colors it with colorId <color>
#
	set repnum [molinfo $molNum  get numreps]
	mol color colorid $color
	mol material Transparent
	mol addrep $molNum
	mol selection all
	mol modstyle $repnum $molNum Isosurface $value 0.0 0.0 0.0
}
